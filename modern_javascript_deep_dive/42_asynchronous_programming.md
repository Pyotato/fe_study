# 42장 비동기 프로그래밍

<details>

<summary> 1. 비동기 처리란?  </summary>

```
비동기 처리란 현재 실행 중인 태스크가 종료되지 않더라도 다른 태스크를 곧바로 실행하는 방식입니다.
setTimeout 함수는 비동기적으로 처리됩니다.
예를 들어 setTimeout처럼 일정 시간 함수 호출을 delay를 시키는 동기적으로 동작하는 함수는 아래와 같습니다.

const bar = ()=> console.log('bar');
const foo = ()=> console.log('foo');

const delay = (func,time)=> {
 const delayTime = Date.now()+time;
 while(Date.now() <delayTime);
 func();
}

delay(foo,1000);
bar();

delay는 setTimeout과는 달리 1000밀리초 후 foo가 호출되고 bar이 호출됩니다.
이는 동기적으로 처리가 돼서 delay함수가 실행중에 블로킹을 발생해서 순차적으로 실행이 밀혔습니다.

하지만, 비동기적으로 처리되는 setTimeout은 함수 실행이 되고 있어도 다른 함수의 실행을 블로킹하지 않습니다.

const bar = ()=> console.log('bar');
const foo = ()=> console.log('foo');

setTimeout(foo,1000); // setTimeout 호출, 1000 밀리초 이후 foo가 출력 (아직 종료 x)
bar(); // 호출/실행
```

</details>

<details>

<summary> 2. 타이머함수, 이벤트 핸들러, HTTP 요청은 비동기적 처리된다. (🅾️ / ❎)  </summary>

```
🅾️
setTimeout과 setInterval의 타이머 함수는 빌트인 함수는 아닙니다.
하지만, nodejs와 브라우저에서 제공해주는 전역 메서드이며, 타이머 함수는 호스트 객체입니다.
```

</details>

<details>

<summary> 3. 자바스크립트는 싱글쓰레드입니다. 실행 컨텍스트 스택이 하나이며, 스택에서 하나씩 실행하고 팝하기 때문에 동시에 실행될 수 없습니다. 하지만, 우리가 보고 있는 웹사이트에서는 여러 동작이 동시에 이루어지는 것같습니다. 어떻게 가능한건가요?   </summary>

![](https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iHhUyO4DliDwa6x_cO5E3A.gif)

```
자바스크립트는 싱글쓰레드이지만, 웹브라우저는 멀티쓰레드입니다.
웹브라우저에는 이벤트 루프와 태스크큐가 있어
웹브라우저에서 동시에 여러 태스크의 동시성을 보장하는 것은 이벤트 루프와 태스크 큐에 의해서 가능합니다.

자바스크립트 엔진은 콜 스택과 힙으로 구성되어 있습니다.
소스코드가 평가되면 실행 컨텍스트에 추가되고 순차적으로 실행되어 콜 스택에서 상위의 실행컨텍스트가 팝되어 제거되기 전까지는
다른 태스크가 실행되지 않습니다.
힙은 객체가 저장되는 메모리 공간으로, 실행 컨텍스트는 힙에 저장된 객체를 참조합니다.

소스코드의 평가와 실행은 자바스크립트 엔진이 하지만, 비동기적인 처리는 브라우저나 Node.js가 담당합니다.
예를 들어, 타이머 함수의 경우, 소스코드를 평가하는 역할은 자바스크립트 엔진이 하지만,
타이머 설정, 콜백함수 등록은 브라우저나 Nodejs가 합니다.

태스크 큐에 비동기 함수의 콜백함수나 이벤트 핸들러가 일시적으로 보관됩니다.
또한, 프로미스의 후속 처리 메서드이 몰백 함수가 일시적으로 보관되는 마이크로태스큐도 있습니다.

이벤트 루프는 콜 스캑에 현재 실행 중인 실행컨텍스트가 있는지, 태스크 큐에 대기 중인 함수아 있는 지 계속 확인합니다.
콜 스택이 비어 있고, 태스크큐에 대기 중인 함수가 있다면, 이벤트 루프는 먼저 대기중이었던 함수를 콜스택으로 이동시킵니다.
콜 스택에 이동한 함수는 실행되고, 이에 따라 태스크 큐에 대기 중이던 함수들이 비동기적으로 처리됩니다.
```

</details>

```js
function foo() {
  console.log("foo");
}

function bar() {
  console.log("foo");
}

setTimeout(foo, 0);
bar();
```

<details>

<summary> 4. 위의 함수는 어떻게 동작하나요? </summary>

```
타이머 함수는 브라우저나 Nodejs가 태스크큐와 이벤트 루프를 통해 동기적으로 처리하는 함수입니다.
위의 실행 결과는 bar이 실행 후, foo가 실행됩니다.
상세한 동작 방식을 살펴보자면,
자바스크립트 엔진이 전역 코드를 평가해서 전역 실행 컨텍스트가 생성되고 콜 스택에 푸시됩니다.
전역 코드가 실행되기 시작하여 setTimeout 함수가 호출되고 실행컨텍스트에 콜스택에 푸시되어 현재 실행 중인 실행 컨텍스트가 됩니다.
setTimeout함수가 실행되면 콜백 함수를 호출 스케줄링하고, 종료되어 콜 스택에서 팝됩니다.
브라우저는 타이머 설정을 하고, 타이머가 만료되면 콜백함수를 태스크 큐에 푸시하는 역할을 합니다.
foo 콜백함수는 브라우저에 의해 타이머가 만료될 때까지 기다리는데, 4ms 이하로 설정되어 있다면 최소 지연시간인 4ms가 만료되기를
기다렸다가, 4ms 이후 태스크 큐에서 푸시되어 대기합니다.
이 때, 자바스크립트 엔진은 bar함수를 호출하여 실행 컨텍스트를 생성하고 콜스택에 푸시되어 현재 실행중인 실행 컨텍스트가 됩니다.
bar이 실행 종료되면 콜 스택에서 팝되고, 전역 실행 컨텍스트도 콜스택에서 팝되어 빈 상태가 되면 이벤트 루프가 이를 감지하고
태스크 큐에서 대기 중이엇던 콜백함수 foo를 콜스택에 푸시합니다.
foo 함수의 실행 컨텍스트가 스택에 푸시되고 실행을 종료하면 콜 스택에서 팝됩니다.

즉, setTimeout의 딜레이 밀리초는 함수를 호출하기까지, 즉, 실행컨텍스트에 푸시되기까지의 시간이 아닌,
태스크 큐에 대기를 하기까지의 시간입니다.
따라서 setTimeout의 비동기 함수는 몇 초를 딜레이하던, 현재 실행 컨텍스트가 빈 상태이어야 콜스택에 푸시되고 실행됩니다.
```

</details>

## 💭 TMI

> 브라우저/nodejs는 멀티쓰레드, 자바스크립트 엔진은 싱글쓰레드다.</br>
> 소스코드 평가해서 힙이랑 콜스택에 실행컨텍스트 푸시하는 역할은 자바스크립트 엔진이,<br/>
> HTTP 요청, 이벤트 핸들링, 타이머 함수 등의 등록 등의 처리 브라우저가 이벤트 루프와 테스크큐를 통해 한다.<br/>
> 실행 컨텍스트는 One at a time..팝되기 전까지는 자바스크립트가 다른 실행컨텍스트를 꺼내올 수가 없음. 다만 콜스택이 다 비어 있는 걸 이벤트 루프가 확인하면 테스크큐에 기다리고 있던 함수들을 콜스택으로 옮겨서 해당 함수의 실행컨텍스트를 실행하고, 자바스크립트 엔진은 해당 실행중인 함수가 종료하면 실행컨텍스트를 팝 후 제거하는 걸 반복.
>
> ```js
> const bar = () => console.log("bar");
> const foo = () => console.log("foo");
> const coo = () => console.log("coo");
> const joo = () => console.log("joo");
>
> coo();
> setTimeout(foo, 0);
> bar();
> setTimeout(joo, 20);
> ```
>
> 한 번 다시 정리하자면, 위의 경우 자바스크립트 엔진에 의해 coo 함수가 호출되어 콜스택에 쌓이고 coo 함수의 실행 컨텍스트가 스택에 쌓인다.
> setTimeout 함수가 호출되어 0초 (최소 딜레이인 4초 후)에 콜백함수를 태스크큐에 대기시킨다.
> 4초가 경과되기 전, coo 함수가 실행을 완료하고 실행컨텍스트에서 팝되면,
> bar함수가 호출되어 실행컨텍스트에 푸시되어 실행된다. 비어 있는 실행 컨텍스트를 이벤트 루프가 감지하고 콜스택으로 옮겨
> 실행 컨텍스트를 푸시하고 foo함수가 실행된다.
> 자바스크립트 엔진은 다음 호출된 setTimeout함수를 콜스택에 푸시하고, 콜백함수 joo는 브라우저에 의해 20 밀리초 후에
> 태스크큐에서 대기하게 되는데, 이벤트 루프는 빈 콜스택을 또 감지해서 joo함수를 콜스택에 옮겨준다.
> joo가 실행중인 실행 컨텍스트가 되어 함수가 실행되고, 종료 후에 팝된다.
> 모든 함수가 호출과 실행을 종료하면, 전역 컨텍스트도 팝된다.
