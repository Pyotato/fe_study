# 7장 연산자

<details>

<summary> 1. 단항 산술 연산자는 모두 부수효과가 없다.(🅾️ / ❎)</summary>

```
❎
단항 산술 연산자에는 ++, --, +, - 가 있습니다.
++와 --은 부수효과가 있지만, + 과 - 은 부수효과가 없습니다.
++와 --은 값을 연산하고 재할당하는 암묵적인 할당 과정이 있지만, + 과 -은 number로 암묵적 변환한 값의 부호를 붙인 새로운 값을 리턴하기 때문입니다.
따라서 피연산자에 +과 -을 붙이면 숫자로의 타입 변환이 이루어집니다.

예를 들면, string 타입 변수 let a = '1'; 에 +a 연산은 1이라는 새로운 number 타입 값을 생성합니다.
boolean 타입인 경우, true라면 1로 false라면 0으로 타입변환을 해서 생성된 값을 리턴합니다.

숫자로 변환할 수 없는 값은 NaN이 됩니다. 예를 들면 let hello = 'hello';라고 할 경우, +hello는 NaN값을 리턴합니다.
'hello' string은 위의 a 변수의 경우처럼 암묵적 형변환을 시도했을 경우 숫자로 나타낼 수 없기 때문입니다.

숫자로의 암묵적 형변환은 boolean 데이터 타입에도 가능한데, 숫자로 형변환할 경우, false는 0, true는 1으로 변환할 수 있습니다.
예를 들어,
let a = false 일 경우, -a는 -0이 됩니다. 여기서, 단항 연산자의 순서는 먼저 number 타입으로 변환하고, 그 뒤에 부호를 붙입니다.
따라서 false를 숫자로 형변환하면 0이 되고, -을 붙이면 -0이 되는 겁니다.

let a = true일 경우에 -a는 -1입니다. 마찬가지로 true를 숫자로 변환하면 1이고, - 단항 연산자에 의해 -1이 됩니다.
```

</details>

<details>
<summary> 2. 후위 단항 연산자와 전위 단항 연산자의 차이가 뭔가요?</summary>

```
후위 단항연산자는 암묵적 할당이 먼저 일어나고 그 후에 연산이 이루지는 반면,
전위 단항 연산자는 연산을 먼저 하고, 그 값이 암묵적으로 할당됩니다.
예를 들어,

let a = 3;이라고 변수를 선언하고, let b = a++; 라고 후위 단항 연산을 하면, b의 값은 3이 되고, a의 값은 4가 됩니다.
let b = a++;을 풀어서 보면, let b = a; a+=1; 과 같습니다.

반면, let a = 3;이라고 변수를 선언하고, let b = ++a; 라고 전위 단항 연산을 하면, b의 값과 a 모두 4가 됩니다.
전위 연산자도 풀어서 보면, let b = ++a; 은 a+=1; let b = a; 입니다.
```

</details>

<details>
<summary> 3. 동등비교(==)와 일치비교(===)의 차이점은 뭔가요? Object.is()에 관해서 알고 있나요?</summary>

```
동등 비교는 단순히 값이 같은 지 평가를 하고, 일치 비교는 값이 같고, 타입 또한 같은 지 여부에 따라 true/false를 반환합니다.
== 연산자는 좌항과 우항의 타입이 일치하도록 타입변환을 시킨 후 값을 비교하는 반면, ===은 좌항과 우항의 값과 타입이 같은 지를 비교합니다.
따라서 일치비교가 더 엄격한 비교입니다.

Object.is()는 NaN 값 간의 비교와 +0과 -0 를 비교할 떄와 같이, 부동소수점을 사용해서 숫자를 나타내는 특성때문에 false로 나오는 경우에 쓰일 수 있습니다.

// 💖💖💖💖💖💖💖💖 NaN==NaN은 왜 false이고, 왜 +0 == -0은 true 일까? 해당 내용을 더 파보자! 💖💖💖💖💖💖💖💖


```

</details>

<details>
<summary> 4. typeof null은 'object'이다.(🅾️ / ❎)</summary>

```
🅾️
null은 null 타입이지만 typeof 연산시에 object를 반환한다.
따라서, null임을 확인하고 싶을 경우 === 연산자를 사용한다.

```

</details>

<details>
<summary> 5. 선언하지 않은 변수의 typeof 연산 결과는 무조건 undefined이다. (🅾️ / ❎)</summary>

```
❎
일반적으로, 선언하지 않은 변수의 typeof 연산 결과는 에러가 아니라 undefined입니다.
하지만, 전역 객체의 속성에 접근한 경우에는 object 타입이 반환될 수 있습니다.
예를 들어, 웹브라우저의 전역 객체는 window입니다.
만약 typeof localStorage를 콘솔로 찍어보면 object 타입임으로 알 수 있습니다.
이는 체이닝에 의해서, 현재 실행 컨텍스트에는 해당 변수 선언을 찾지 못했기 때문에,
상위의 컨텍스트로 올라가다 최상위의 global에서 해당 객체의 타입을 반환한 것입니다.
```

</details>

<details>
<summary> 6. 이항 연산자 중에서 가장 높은 우선 순위를 지닌 연산자는 무엇인가요? </summary>

```
`**` 지수 연산자가 이항 연산자 중에서 제일 우선 순위가 높습니다.
```

</details>

## 💭 TMI

> 단축평가, 옵셔널 체이닝 (?.), (??) null 병합 연산자, delete, new, instanceof, in 등의 연산자들에 대해서는 각 장에서 자세히 다뤄보고 질문리스트를 생략했다. NaN != NaN이라는 것이 좀 신기했다. 좀만 생각해보면 맞는 말이긴 하다. (-2)의 제곱근이나 (-3)의 제곱근은 모두 NaN인데 그 둘이 같다고 보는 거 자체가 이상하다. 이는 컴퓨터가 부동소수점으로 숫자를 표현하기 때문에 생긴 특징들이라고 하는 글을 봤는데 더 자세히 읽어보고 내용을 정리해 봐야겠다.
