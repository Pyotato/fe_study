# 13 스코프

<details>
<summary> 1. 스코프란? </summary>

```
스코프란 식별자의 유효범위 또는 식별자를 검색할 때 사용하는 규칙입니다.
예를 들어, 함수 내에서 선언된 변수는 함수 내부에서만 참조 가능합니다.
변수 뿐만 아니라, 함수, 클래스 등 모든 식별자는 자신이 선언된 위치에 따라 유효한 범위인 스코프가 결정됩니다.
스코프에는 지역 스코프와 전역 스코프가 있습니다.
전역 스코프를 갖는 식별자는 어디에서든 참조가 유효한 반면,
지역 스코프는 자신을 포함한 하위의 스코프들에서만 참조 가능합니다.

예를 들어,

const a = 1; //    전역 스코프

function outer(){
    let b = 2; // 지역 스코프 1
    function inner(){
        let c = 3; // 지역 스코프 2
        console.log(b);
    }
    console.log(a);
    // console.log(c);  // reference error;
    inner();
}

outer();
// inner(); // reference error;

위의 코드에서 a, outer는 전역 스코프를, b, c와 inner는 지역 스코프를 지녔습니다.

따라서 outer()로 함수를 호출하면 console.log(a)에서 전역 스코프의 식별자 a를 참조하여 1을 출력하고, 다음으로는 inner함수를 호출하였으므로
지역스코프이자 지역 스코프의 하위스코프인 outer의 변수 b를 참조하여 2를 출력합니다.

```

</details>

<details>
<summary> 2. 스코프 체인이란? </summary>

```
스코프 체인이란 중첩된 스코프들이 계층적으로 연결된 것입니다.
최상위 스코프는 전역 스코프이며, 이는 하위의 모든 지역 스코프가 참조 가능합니다.
자바스크립트에서는 변수를 참조할 때, 자신의 스코프에서 시작하여, 해당 스코프에 없을 경우, 상위의 스코프를 타고가면서 변수 검색을 합니다.

```

</details>

<details>
<summary> 3. 블록 레벨 스코프와 함수 레벨 스코프가 어떻게 다른 지 var를 포함하여 예 들어 설명해주세요. </summary>

```
자바스크립트의 변수 선언 키워드에는 var, let, const가 있는데,
var은 함수 레벨 스코프를, let과 const는 블록 레벨 스코프를 따릅니다.
즉, var 키워드는 함수 내부에서 선언되면 해당 함수 내에서만 참조가 가능한 유효범위를 지니지만, 그 외의 경우에는 전역 스코프를 지니게 됩니다.
반면 블록 레벨 스코프는 함수 뿐만 아니라, {} 중괄호로 묶는 블록에 의해서 스코프가 결정됩니다. 따라서 try catch문, while문, if문 등의 블록에서 선언한 식별자는 해당 블록에서 스코프가 형성됩니다.

함수 레벨 스코프를 지닌 var는 변수명이 중복되어도 문제가 되지 않아, 재선언이 가능하고, 이에 따라서 의도치 않게 변수 재할당이 발생할 수 있다는 문제가 있습니다.

예를 들어,

var a = 1;
if(true){var a = 3;}

console.log(a); //3

위의 경우에서 블록 레벨 스코프라면 {}중괄호로 감싼 블록이 식별자의 유효범위를 형성합니다. 반면 함수 레벨 스코프는 해당 블록이 함수가 아니므로 해당 스코프를 벗어난 전역 스코프에서 참조 가능합니다. 따라서 a의 식별자는 3이라는 값으로 재선언되고 할당되었습니다.

var a = 1;
function add(){
    console.log(a); // ?
    var a = 2;
    var b = 3;
    return a;
}

console.log(add()); // 2
console.log(a); // 1
console.log(b); // reference error

위의 경우, 함수 레벨 스코프이므로, var로 선언한 식별자는 함수 블록을 식별자의 유효 범위 가집니다.
따라서 add() 함수를 호출할 경우 리턴한 값은 함수 내부에서 참조한 식별자인 a = 2입니다. console.log(a)에서 자신의 스코프(전역 스코프)에서 1을 출력합니다. console.log(b)에서 식별자 b는 add 함수가 유효 스코프이므로, 스코프 체인 규칙에 따라, 상위 스코프는 하위 스코프를 탐색할 수 없기 떄문에 참조 에러가 발생합니다.

add 함수 내부의 console.log(a)의 결과는 무엇일까요?
2라고 답했다면 블록레벨 스코프에 대한 이해는 어느 정도했다는 것이겠지만
, 2가 아니라 undefined가 정답입니다.
이는 호이스팅과 관련되어 있습니다. 함수 레벨 스코프를 지닌 변수 a는 해당 스코프에서 변수가 호이스팅 되었고, undefined으로 암묵적 초기화가 되었습니다.
따라서 할당을 하기 이전이므로 이 초기화값이 출력됩니다.

```

</details>

<details>
<summary> 4. 렉시컬 스코프란? </summary>

```
렉시컬 스코프란 식별자가 선언된 위치에 따라 해당 식별자의 유효범위가 정적으로 정해지는 스코프입니다.
예를 들어, 자바스크립트에서는 함수가 선언된 위치에 따라 스코프가 정해지는데, 이는 렉시컬 스코프를 따른 것입니다. 함수가 전역에서 정의/선언된다면 해당 함수의 스코프는 전역 스코프를 유효 범위로 하고, 함수가 중첩되어있는 다른 함수 내부에서 정의/선언된다면 해당 함수의 유효범위는 외부함수입니다. 즉, 중첩된 함수는 외부함수를 참조하고, 스코프 체인을 따라 최상단의 전역 스코프까지 접근 할 수 있지만, 렉시컬 스코프를 벗어난 범위에서는 해당 중첩함수를 참조할 수 없습니다.

```

</details>

<details>
<summary> 5. 다음의 실행 결과가 뭘까요?
  
```js
var x = 1;
function foo() {
  var x = 10;
  bar();
}

function bar() {
console.log(x);
}

foo();
bar();

````

</summary>


```html
결과는 1이 두번 출력됩니다.
자바스크립트의 스코프는 식별자의 유효범위는 렉시컬 스코프, 즉 식별자가 선언된
위치를 따릅니다.
변수 x, foo 와 bar함수의 선언 위치는 전역입니다.
따라서 모두 전역 스코프를 지녔습니다.
foo함수를 호출했을 경우, bar함수가 호출되는데,
bar 함수는 자신의 스코프에 식별자 x가 없습니다.
스코프 체인을 따라 상위 스코프인 전역 스코프에서 식별자 x를 찾아 이를 출력합니다.
bar를 한번 더 호출하여 다시 1이 출력됩니다.
````

</details>

## 💭 TMI

> 질문 3에서의 코드 예를 들었던 부분에서는 복습 겸 호이스팅의 개념까지 접목해서 넣어봤다. <br/>
> var는 함수 레벨 스코프를 가진대 ➡️ 오 그럼 함수 내에서 재선언하면 어떻게 될까? ➡️ 함수에서 식별자가 유효한 범위가 생긴다 ➡️ 함수 내의 변수 호이스팅 발생<br/>
> 예전에 모던 자바스크립트를 읽었을 때는 다른 개념들을 연관 지을 만큼 이해하진 못했던 거 같지만 유관한 개념들을 생각해낼 수 있다는 게 좀 뿌듯하다.
