# 10장 객체 리터럴

<details>
<summary> 1. 객체가 뭔가요?  </summary>

```
객체란 키와 이루어진 여러 데어터 타입의 값으로 이루어진 자료 구조입니다. 자바스크립트에서 원시 타입 값을 제외한 모든 값은 객체입니다.
즉, number, string, undefined, null, boolean, symbol을 제외한 모든 값은 객체 타입입니다. 객체는 프로퍼티를 지녔는데, 이는 키와 값 쌍으로 이루져 있습니다. 값으로는 모든 타입의 데이터가 들어갈 수 있으며, 함수가 값인 경우 이 함수를 일반함수와 구분하여 메소드라고 합니다. 험수는 일급 객체이므로 값으로 쓰일 수 있기 때문입니다.
객체를 생성할 수 있는 방식에는 new 와 생성자를 통해 인스턴스를 만드는 방법이 있고, {} (증괄호)로 객체 리터럴을 이용해 객체를 생성할 수 있습니다.
```

</details>

<details>
<summary> 2. 자바스크립트에서 객체의 값에 접근하는 방법 두가지?  </summary>

```
객체는 `.`(마침표 프로퍼티 접근 연산자)를 통한 마침표 표기법, `[]` (대괄호)를 사용해 접근할 수 있는 대과롷 표기법이 있습니다.
주의 할 점은 객체의 키가 변수 명명 규칙을 준수한 경우 마침표 표기법으로 접근가능하나, 아닌 경우 '' 나 "" 으로 감싸 대괄호 표기법으로만 접근할 수 있다는 점입니다. 만약 해당 키에 값이 없다면 에러가 아닌 undefined가 반환됩니다. 또한, ''나 "" 없이 대괄호 표기법을 사용할 경우, 변수로 판단하여 해당 변수가 키 값이 아닌 경우 undefined을 리턴하게 됩니다.

```

</details>

<details>
<summary> 4. nodejs와 브라우저 환경에서 person 빈 객체를 선언했다고 할때, `person.last-name`의 결과값이 뭘까요?  </summary>

```
person.last는 빈 객체에서 없는 키의 값에 접근을 시도한 것이므로 undefined이 됩니다. 여기서 -name은 숫자 연산자이므로 name을 숫자로 암묵적 타입 변환을 하는데, nodejs에서는 name은 선언하지 않은 변수가 되어 결과가 undefined이 됩니다.
반면, 브라우저 환경에서 name은 전역 객체 window의 프로퍼티이며, 기본적으로 빈문자열 ''이 되므로 암묵적 타입변환에 의해 빈문자열은 0이 됩니다. undefined-0을 연산하면 NaN이 됩니다.
```

</details>

<details>
<summary> 5. E6에서 객체 리터럴 확장된 예 3가지에 대해 알고 계시나요?  </summary>

```
E6에서는 프로퍼티 축약 표현, 계산된 프로퍼티 이름, 메서드 축약 표현이 있습니다.
프로퍼티 축약 표현은 키와 값으로 할 변수의 이름이 같으면 키 이름을 생략하여 변수 이름이 자동적으로 생성되게 하는 기능입니다.
예를 들어 let x= 3; 이고 let a= {x:x}인 경우, let a = {x}로 쓸 수 있습니다.

계산된 프로퍼티 이름은 대괄호로 연산된 리터럴을 키로 쓸 수 있는 기능입니다.
예를 들어 let a = {} for(i==1,;i<4;i++) a[`${i}-key`] = i;와 같이 템플릿 리터럴의 결과로 키를 동적으로 생성할 수 있습니다.

메서드 축약 표현은 함수를 값으로 하는 프로퍼티에서 키를 생략하여 바로 함수를 선언하면 자동으로 해당 메서드의 키가 함수명으로 생성되는 것입니다.
예를 들면, let a = {sayHi:function(){console.log('hi');}}으; 경우 let a = {sayHi(){console.log('hi');}} 로 축약 가능합니다.
```

</details>

## 💭 TMI

> 변경 불가능(immutable)하고 변경가능(mutable)한 값에 대해 살짝 언급했지만 11장에서 더 자세히 이 내용을 다뤄봐야겠다.<br/>
> 코어 자바스크립트에서는 값에 대한 참조는 변경 가능한 데이터 타입이든 변경 불가능한 데이터 타입이든 발생한다고 얼핏 읽었다.<br/>
> 이는 데이터 타입에 따라 할당되는 메모리 공간이 다르기 떄문인데, 원시 타입의 데이터는 정해진 크기의 용량이 할당되어 스택에 쌓이는 반면, 참조타입의 데이터는 삽입과 삭제가 자유로워 크기 할당이 동적으로 변할 수 있는 힙 영역에 할당된다고 했던 것 같다.<br/>
> 즉, 원시 타입인 숫자 3은 변경 불가능한 값인데, 만약 다른 값으로 할당을 하려고 한다면 스택 공간에 다른 값을 생성해서 그 주소를 참조하고, 숫자 타입의 데이터는 정수 실수 무관하게 8바이트가 할당되므로 그 만큼 읽어온다고 했던 거 같다. 즉, 3이라던 값이 차지하고 있던 메모리 공간은 그 값을 참조하고 있는 변수가 없을때 가비지 콜렉트되는 것이지, 해당 값을 다른 값, 예를 들어 4로 변경되는 것이 아니라는 것이다.<br/>
> 반면에, 객체 타입의 데이터는 참조가 두번 일어난다고 읽었던 거 같다. 내가 이해한 바로는 키에 대응하는 값이 저장되어 있을 것인데, 그 값의 메모리 주소가 저장되어 있고, 그 메모리 주소로 가면 데이터가 값의 메모리 주소를 지니고 있다는 것이다.
> 예를 들면, let a = {x:3, y:[1,2,3]};이라고 할 경우, a의 경우 x와 y가 할당된 힙 영역 메모리 주소가 있고, x가 참조하는 건 숫자 타입의 데이터이므로 스택에 저장되어 있는 3의 메모리 주소를 저장하고 있는 반면, 키 y의 값의 데이터 타입은 배열이므로 힙에서 배열의 주소 범위가 담겨져 있고, 각 숫자들의 메모리 주소가 스택에 있다는 것이다.<br/> > [저번에 살펴봤던 gc](https://github.com/Pyotato/fe_study/blob/main/modern_javascript_deeper_dive/1_garbage_collection.md#%EA%B0%80%EB%B9%84%EC%A7%80-%EC%BB%AC%EB%A0%89%EC%85%98)에서 데이터 타입에 따라 참조 메모리 주소 참조 회수가 달라지는 걸 볼 수 있다.
