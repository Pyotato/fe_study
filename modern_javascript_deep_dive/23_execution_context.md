# 23장 실행 컨텍스트

<details>

<summary> 1. 소스코드의 타입에는 어떤 것들이 있나요? 실행 컨텍스트와는 어떤 관계가 있나요?  </summary>

```
소스코드의 타입에 따라 생성되는 실행컨텍스트가 다르기 때문에 소스코드이 타입을 아는 것이 중요합니다.
소스코드에는 전역코드, 모듈 코드, eval 코드, 함수 코드가 있습니다.

전역 코드는 전역에 존재하는 소스코드입니다. 전역에 정의된 함수, 클래스 등의 내부 코드는 포함하지 않습니다.
모듈 코드는 모듈 내부에 존재하는 소스코드로, 모듈 내부의 함수, 클래스 등의 내부 코드는 포함하지 않습니다.
eval 코드는 eval 함수에 인수로 전달되어 실행되는 소스코드입니다.
마지막으로 함수 코드는 함수 내부에 존재하는 소스코드입니다. 다만, 함수 내부에 중첩된 함수, 클래스 등의 내부 코드는 포함되지 않습니다.

각각의 소스 코드는 형가되면 각각의 실행 컨텍스트를 생성합니다.
전역 코드는 var 키워드로 선언한 전역 변수, 함수 선언문으로 정의한 전역 함수를 전역 객체의 프로퍼티와 메서드로 바인딩합니다.
모듈 코드는 모듈별로 독립적인 모듈 실행 컨텍스트가 생성됩니다.
eval 코드는 strict mode에서 독자적인 스코프를 지닌 실행컨텍스트가 생성됩니다.
마지막으로, 함수 코드는 지역 스코프를 생성하고 지역변수, 매개변수, arguments 객체를 관리하고,
생성된 지역 스코프를 전역 스코프와 연결을 해주기 위한 함수 실행 컨텍스트가 생성됩니다.
```

</details>

```js
var x;
x = 10;
```

<details>

<summary> 2. 위 코드에서 자바스크립트의 평가와 실행 과정에 어떤 일이 발생하나요?</summary>

```
자바스크립트는 실행에 앞서 평가의 과정이 있습니다.
평가 과정에서는 실행 컨텍스트를 생성하고, 변수, 함수 등의 선언문만 먼저 실행하여
생성된 변수나 함수 식별자를 키로 실행컨텍스트가 관리하는 렉시컬 환경의 환경 레코드에 등록합니다.
소스코드 평가과정이 끝나면 선언문 외의 소스코드가 순차적으로 시작합니다.
소스 코드의 실행에 필요한 변수나 함수가 해당 환경 레코드에서 검색되거나 코드 실행 결과가 반영되어 등록됩니다.

위의 경우, 소스 코드 평가과정에서 전역에 선언된 var 변수 x는 전역 객체의 프로퍼티로 등록되고,
var 키워드로 선언된 변수는 선언과 초기화가 동시에 이루어지므로, 할당문 이전에 undefined으로 초기화되고
소스코드 평가 과정이 끝납니다.
소스코드 실행과정에서는 x = 10에서는 식별자 x가 존재하는 지, 해당 스코프에서 검색하고, x가 존재하므로 10을 할당합니다.
```

</details>

<details>

<summary> 3. 실행 컨텍스트란? 실행 컨텍스트가 필요한 이유와 함께 설명해주세요.  </summary>

```
실행 컨텍스트란, 코드가 실행하기 위한 변수, 함수 등 환경을 제공하고 실행 결과를 관리하는 영역입니다.
즉, 실행 컨텍스트는 변수, 함수 클래스 등을 등록하고 관리할 렉시컬 스코프와
코드의 실행 순서를 관리할 실행 컨텍스트를 통해 코드를 실행을 관리하는 역할을 합니다.
```

</details>

```js
const x = 1;

function foo() {
  const y = 2;
  function bar() {
    const z = 3;
    console.log(x + y + z);
  }
  bar();
}

foo();
```

<details>

<summary> 4. 위의 코드에서 실행 컨텍스트가 어떻게 동작하나요?  </summary>

```
위의 코드에서 함수 선언문으로 정의한 전역 함수 foo는 소스코드 평가과정에서
전역 객체의 프로퍼티로 등록됩니다.
const로 선언한 변수 x는 독자적인 렉시컬 환경이 생성됩니다.
함수가 선언되기 전, 전역 실행 컨텍스트가 생성되고 실행 컨텍스트 스택에 쌓입니다.
foo 함수를 실행하게 되면 이 실행 컨텍스트가 실행 컨텍스트 스택위에 쌓이고,
제어권이 foo 에게 넘어갑니다.
foo 함수의 실행 컨텍스트에는 함수 내부에서 쓰일 지역 변수인 y와 중첩 함수 bar가 등록됩니다.
bar 함수가 실행되면, bar 함수의 실행 컨텍스트가 생성되며 지역 변수 z와 console 함수가 등록됩니다.
console 함수는 해당 식별자가 스코프에 있는 지 검색하고, 없으면 상위의 스코프로 넘어가 검색합니다.
자신의 스코프인 bar에도, 상위 스코프인 foo에도 없으므로, 스코프 체인을 따라 검색하다 전역객체의 console의 메소드log를 호출합니다.
이후, bar 함수는 실행을 종료하였기 때문에 해당 실행 컨텍스트는 스택에서 pop되고, foo와 전역 실행 컨텍스트도 순서대로 pop 되어
함수 실행이 완료됩니다.
```

</details>

<details>

<summary> 5. 렉시컬 환경은 무엇으로 구성되어 있나요? </summary>

```
렉시컬 환경은 EnvironmentRecord(환경 레코드)와 OuterLexicalEnvironmentReference(외부 렉시컬 환경에 대한 첨조) 컴포넌트로 구성됩니다.
EnvironmentRecord에는 스코프에 포함된 식별자를 등록하고 등록된 식별자에 바인딩된 값을 관리하는 저장소입니다.
OuterLexicalEnvironmentReference는 상위 스코프를 가르킵니다.
싱위 스코프는 해당 실행컨텍스트를 생성한 소스코드를 포함하는 상위 코드의 렉시컬 환경입니다.
```

</details>

<details>

<summary> 6. 실행 컨텍스트 생성 과정과 식별자 검색 과정에 대해서 설명해주세요. </summary>

```
전역 코드가 실행되기 전, 평가과정에서 전역 객체가 생성됩니다.
그 후, 전역 코드가 평가될 때 전역 실행 컨텍스트가 생성되고, 전역 렉시컬 환경이 생성됩니다.
이 전역 렉시컬 환경은 전역 실행 컨텍스트을 가리킵니다.
전역 스코프를 관리하는 GlobalEnvironmentRecord는
var 키워드로 선언한 전역 변수를 관리하는 Object Environment Record (객체 환경 레코드)와,
let과 const 키워드로 선언한 전역 변수를 관리하는 Declarative Environment Record(선언적 환경 레코드)으로 구분됩니다.

Object Environment Record에는 BindingObject와 연결되어 있는데, BindingObject는 코드 평과과정에서 생성되었던 전역 객체다.
전역 코드 평가 과정에서 var로 선언된 전역 변수와 함수 선언문으로 정의된 함수는 전역 환경 레코드의 Object Environment Record에 연결된 BindingObject를 통해 전역 객체의 프로퍼티와 메서드가 됩니다.

Declarative Environment Record는 let이나 const 키워드로 선언된 전역 변수가 등록되고 관리됩니다.
Object Environment Record와는 달리, 전역 객체의 프로퍼티가 아니므로, window 와 프로퍼티 접근 연산자로 접근이 불가능합니다.

그 다음에는 GlobalEnvironmentRecord와 함수 환경 레코드에 this 바인딩이 이루어지며, 외부 렉시컬 한경에 대한 참조가 결정됩니다.
GlobalEnvironmentRecord는 [[GlobalThisValue]] 내부 슬롯에 this가 바인딩됩니다.
전역에서 this를 참조하면 전역 객체를 가르키고, 함수 환경 레코드는 함수의 호출 방식에 따라 동적으로 this가 바인딩됩니다.
함수가 상위 스코프의 존재 여부에 따라 외부 렉시컬 한경에 대한 참조가 결정됩니다.
전역 코드는 상위 스코프가 존재하지 않으므로 null 값이 할당됩니다.

```

</details>

## 💭 TMI

> 실행컨텍스트..뭔가 복잡한 하나의 주제를 살짝 넘어본 느낌이었다.<br/>
> 결국 실행 컨텍스트를 내 나름대로 정리하자면, 코드를 실행하기 위해서는 `무엇`과 `어떻게`가 필요한데,<br/>
> 코드의 식별자나 스코프등에 해당되는 `무엇`을 관리해주는 렉시컬 환경과,<br/>
> 코드의 실행흐름에 해당되는 `어떻게`를 관리해줄 실행 컨텍스트 스택으로 구성되었다고 크게 볼 수 있는 것 같다.<br/>
> 렉시컬 환경은 또 다시, var으로 선언된 전역변수나 함수 선언문으로 정의된 전역 함수들을 관라힐 Object Environment Record와<br/>
> let과 const로 선언한 전역 변수 Declarative Object Record를 관리할 컴포넌트로 나뉘는데,<br/>
> Object Environment Record같은 경우, 코드 실행 이전, 전역 객체의 프로퍼티나 메소드로 등록하고 어디서든 접근이 가능하도록 한다.<br/>
> 그리고, this는 결국, 동적으로 정해지는 함수 환경 레코드나, 전역 객체를 가르키는 전역 환경 레코드에만 존재한다.<br/>
> 외부 렉시컬 스코프 또한, 스코프 체인의 마지막에 있는 경우, 전역 스코프인 경우 없고, 아닌 경우에는 정의/선언되었던 위치의 상위 스코프를 가르킨다.<br/>
> 함수가 실행되는 과정은, 실행 컨텍스트에 전역 실행 컨텍스트가 먼저 쌓이고, 함수가 실행되는 차례대로 위에 쌓이고 실행을 마치면 해당 실행 컨텍스트부터 팝되는 과정을 통해, 실행 컨텍스트 스택에 모든 스택을 제거하는 과정이다. <br/>
> 이 정도로 정리해 볼 수 있지 않나 싶다.
