# 22장 this

<details>

<summary> 1. 'this'란? </summary>

```
this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수입니다.
객체는 상태를 나타내는 프로퍼티나 동작을 나타내는 메서드를 하나로 묶은 데이터 집합입니다.
this는 객체 자신이 프로퍼티나 동작들을 참조할 수 있도록 합니다.
```

</details>

<details>

<summary> 2. this 바인딩에 대해서 알고 계시나요?  </summary>

```
this 바인딩이란, 식별자(this)와 값(this가 가리킬 객체)을 연결하는 것입니다.
this 바인딩은 함수를 호출하는 방식에 따라 동적으로 결정됩니다.
함수 호출은 일반함수로 호출, 생성자 함수로 호출, 메서드로 호출, Function.prototype.apply/call/bind으로 간접 호출하는 방식이 있습니다.
this 값이 가리키는 값은 이 호출 방식들에 따라 달라집니다.
```

</details>

<details>

<summary> 3. [꼬리질문] 함수 호출 방식에 따라 this가 가리키는 바가 달라진다고 하셨는데, 어떻게 다른가요?  </summary>

```
함수 호출 방식으로는 일반 함수, 생성자 함수, 메서드, Function.prototype.call/bind/apply로의 간접 호출이 있습니다.

일반함수에서의 this는 전역객체입니다. 일반 함수는 객체를 생성하지 않기 때문에 자기참조가 불필요하다는 점에서 strict mode에서는 undefined가 됩니다. 메서드 내부에 중첩된 함수, 혹은 콜백함수에서의 함수가 일반함수로 호출될 경우, this은 전역객체를 가리키게 됩니다.

메서드로 호출하는 경우, 마침표 프로퍼티 접근 연산자인 (.)으로 호출한 객체가 지닌 프로퍼티의 함수를 참조한 것입니다.
즉, 메서드로 호출한 함수는 .으로 호출한 인스턴스 객체를 가르키고, 호출한 객체에 바인딩됩니다.
메서드 내부의 this가 메서드를 갖고 있는 객체가 아닌, 호출한 객체를 가르키는 이유는 메서드는 프로퍼티에 바인딩되는 되기 떄문입니다.
메서드는 객체에 포함된 것이 아닌, 독립적으로 존재하는 별도의 객체입니다. 메서드의 프로퍼티가 이 객체를 가르키는 것이므로, 메서드를 변수에 할당하여 일반 함수로 호출하면 메서드 내부의 this는 전역객체가 되며, 메서드를 다른 객체의 프로퍼티로 등록한다면 메서드 내부의 this는 해당 객체의 프로퍼티가 되어, 호출한 객체를 가르킵니다.

생성자 함수로 함수를 호출할 경우, this는 현재 앞으로 생성될 객체를 가르킵니다.
즉, new 연산자와 함께 생성자 함수로 생성될 인스턴스가 this가 참조하는 대상입니다.

마지막으로, Function.prototype.call/bind/apply로 함수를 호출할 경우, this는 첫번째 매개변수로 전달된 값을 가르킵니다.
call, bind, apply는 Function.prototype의 메서드이며, 모든 함수가 상속받아 자유롭게 쓸 수 있습니다.
세 메소드 전부 매개변수의 첫째 값으로 this로 사용할 객체를 받습니다.
call과 apply는 첫째 인자로 쓰일 this 객체, apply는 매개변수로 전달할 인수 리스트의 배열 또는 유사배열 객체를 받고,
call은 인수리스트를 받는다는 차이가 있습니다.
bind는 매개변수로 전달될 값으로 this가 바인딩할 객체를 받고, 이 객체를 this로 가르키고 있는 새로운 함수를 생성합니다.
bind를 통해 this가 불일치하는 상황을 해결할 수 있습니다.
예를 들어, 함수는 일반함수로 호출할 경우와, 생성자 함수로 호출할 경우, 가리키는 this가 달라집니다.
중첩함수인 생성자 함수 내부에 this가 있고, 내부 함수가 일반함수로 호출된다면, 일반 함수의 this는 전역객체가 되고, 생성자함수로 호출된 함수 내부의 this는 앞으로 지금 생성될 인스턴스를 가르키게 되어 혼돈을 야기할 수 있습니다.
여기서 bind를 통해 내부 일반함수가 bind 할 객체를 생성자 함수 내부의 this로 바인딩하면 this가 가르키는 대상을 일치시킬 수 있습니다.

```

</details>

## 💭 TMI

> 면접 단골이라고 듣던 this에 대해 알아볼 수 있는 기회였다. <br/>
> 전에 자바스크립트의 this는 뭔가 복잡하다는 말, 함수 정의 방식에 따라 쓰임이 달라진다는 말, 괴담(?)을 많이 들었지만, 알고보니 모르는 것에 대한 두려움이 조성한 분위기였을 뿐..착한 친구였다! 같은 느낌
> 결국, this가 가르키는 대상은 함수의 호출 방식에 따라 동적으로 변한다는 것만 알고 가고,<br/>
> 추가적으로 호출 방식의 용도에 따라 this도 다르다는 것만 알고 있으면 별로 헷갈리지 않는 거 같다.<br/>
> 일반함수로 호출하면, 객체를 생성할 일이 없으니 가르킬 대상도 프로퍼티 체인의 최상위로 올라가서 전역이 되고..(내 스코프 안에서 참고할 객체가 있나?없네..를 반복하다보니 전역객체까지 가버린 케이스),<br/>
> 생성자 함수로 호출되는 경우는 더 쉬운게, 애초에 인스턴스를 생성하기 위한 목적이 있었으니 이 생성될 객체를 가리키는게 당연하고,<br/>
> 메서드는 객체가 메서드를 포함하는 게 아니라, 독립적인 객체라는 점, 다만 객체 프로퍼티가 그 독립적인 함수 객체를 가리키고 있다는 점만 알면, 프로퍼티 접근 연산자 앞에 그것을 가리키는 것인 걸 쉽게 알 수 있다.<br/>
> Function.prototype.call/bind/apply는 애초에 쓰이는 목적을 알면 this가 자동으로 뭔지 알 수 있는 구조다.
> 매개변수로 전달받는 첫째 값을 this가 가르킬 대상으로 하고, call/apply는 함수 호출, bind는 그 대상에 바인딩된 함수 리턴하는 목적이라면 어려운 대상이 아니다.
