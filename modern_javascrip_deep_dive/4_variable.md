# 4장 변수

<details>
<summary>1. <i>변수</i>의 정의</summary>

```
변수(variable)란 값을 저장하기 위해 할당된 메모리 공간
```
</details>

<details>
   
<summary>2. <i>식별자</i>의 정의</summary>

```
식별자(identifier)란 변수를 구분하기 위해 붙인 이름
```
</details>

<details>
<summary>3. 변수 선언 키워드 <i>var</i>은 선언과 초기화가 동시에 이루어진다 (🅾️ / ❎)</summary>

```
🅾️
var 키워드로 선언된 변수는 자바스크립트 엔진에 의해서 선언과 동시에 암묵적으로 undefined값으로 초기화됩니다. 
```
</details>

<details>
<summary>4. (3 꼬리질문) <i>var</i>은 어떤 값으로 초기화되고, 왜 초기화가 되는가?</summary>

```
var은 선언 시에 암묵적으로 undefined라는 값으로 할당된다. 
이는 애플리케이션이 이전에 해당 변수로 선언했던 값인 쓰레기 값을 참조하는 에러를 막기 위해서입니다.
이는 자바스크립트가 이전에 가비지 컬렉트하던 방식과 밀접합니다. 자바스크립트에서는 메모리를 회수하기 위해 가비지 컬렉터는 더 이상 참조되지 않는 변수에 할당되었던 메모리를 해제합니다. 이때 자바스크립트는 reference count를 체크해서 이 값이 0이 되었을 경우 메모리를 해제하지만, 체크에 오류가 발생하면 메모리 누수가 발생했습니다. 이러한 reference count 체크 오류를 방지하기 위해 변수 선언 시 undefined으로 초기화하여, 전에 해제를 실패했을 경우에도 쓰레기값을 참조하지 않도록 했습니다.
// 💖💖💖💖💖 현재 자바스크립트엔진에서 쓰는 gc 알고리즘 mark-and-sweep 내용 추가하기 💖💖💖💖💖

```
</details>

<details>
<summary>5. <i>실행 컨텍스트</i>의 저장 위치는?</summary>

```
실행 컨텍스트는 스택에 저장됩니다. 
```
</details>

<details>
<summary>6. <i>변수의 호이스팅</i>이란?</summary>

```
호이스팅은 함수 전체 혹은 변수의 선언부가 코드 최상단으로 끌어올려지는 것과 같은 효과가 발생하는 것입니다.
변수의 호이스팅은 선언부만 끌어올려지기 때문에, 선언과 동시에 암묵적으로 undefined값으로 초기화된 var 변술에 접근하면 undefined 값이, 초기화 이후에만 접근한 let과 const 로 선언된 변수는 TDZ(temporary-dead-zone)에 빠지게 되어 reference error가 발생합니다. 
```
</details>

<details>
<summary>7. 호이스팅은 왜 발생하는가?</summary>

```
호이스팅이 발생하는 이유는 소스코드의 평가가 코드를 순서대로 한줄씩 읽어가는 런타임에 발생하기 이전에 이뤄지기 떄문입니다. 자바스크립트 엔진은 코드를 한줄씩 실행하기 전, 코드를 실행하기 위해 필요한 변수와 함수의 선언이 선언위치와 무관하게 제일 먼저 실행됩니다. 
```
</details>

<details>
<summary>const 로 선언한 변수는 상수이므로 무조건 값을 변경할 수 없다 (🅾️ / ❎) </summary>

```
❎
const로 선언한 변수가 상수라고 하는 이유는, 할당을 초기화 시에 한번만 할 수 있기 때문입니다.
값을 변경할 수 있음의 유무는 'immutable/mutable value'과 관련이 있습니다.
즉, 원시 타입/ 참조타입이냐 값의 타입에 따라서 변경 가능성을 다룰 수 있는 것이고, const가 상수라는 것은 재할당 가능 여부에 관한 것입니다.
예를 들면, 

const arr = [1,2,3];
arr.push('a');

위의 경우, arr의 배열은 초기화 시에 [1,2,3]에서 [1,2,3,'a'] 가 되어, 값이 변경되었습니다.
이는 배열이 mutable 데이터 타입이기 때문입니다. 하지만 변수 arr가 초기화 시에 가리키고 있는 메모리 공간 주소는 변하지 않았습니다.

반면, 아래와 같이 const로 선언한 변수를 다른 값으로 재할당하려는 경우 에러가 발생합니다.
이는 아예 다른 메모리 공간을 arr가 참조하도록 변경하려했기 때문입니다.

const arr = [1,2,3];
arr = [1,2,3];
```
</details>

