# Critical Rendering Path

Critical Rendering Path(CRP)란, 브라우저가 HTML, CSS, JS을 화면의 픽셀로 변환하는 일련의 과정입니다. Critical Rendering Path를 최적화하여 랜더링 성능을 개선할 수 있습니다.
CRP은 DOM, CSSOM, 랜더 트리, 레이아웃으로 구성됩니다.

DOM (document object model)은 HTML 파싱이 되었을 때 생성됩니다. 이 HTML은 JS의 요청에 따라 DOM을 변경할 수 있습니다.
HTML 내부에는 스타일을 위한 요청을 포함하며, CSSOM (CSS object model)을 생성합니다.
브라우저 엔진은 두 개를 합쳐 랜더 트리를 생성합니다.
레이아웃은 페이지 내부의 모든 요소들의 크기와 위치를 정합니다.
레이아웃이 결정되면 스크린 상의 픽셀들이 칠해집니다.

CRP최적화는 첫 랜더링 시간을 개선합니다.
CRP를 이해하고 최적화하는 것이 reflow와 repaint가 초당 60 프레임에 이루어지고, 원만한 유저 상호작용과, 버벅거림(jank)을 방지하는데 중요한 요소로 작용합니다.

## CRP 이해하기

웹 성능은 서버 요청과 응답, 로딩, 스크립트화, 랜더링, 레이아웃과 픽셀을 화면에 페인트하는 과정에 의해 결정됩니다.

웹이나 앱 요청의 시작은 HTTP 요청에서 시작됩니다.
서버는 HTML을 포함한 응답을 보냅니다.
브라우저는 받은 HTML을 파싱하는데, 바이트들을 DOM 트리로 전환합니다.
외부 리소스에 대한 링크를 찾을 때마다, 브라우저는 스타일시트나 스크립트, 임베드된 이미지 참조에 대한 요청을 시작합니다.

어떤 요청들은 블로킹(`blocking`)을 일으키는데, 해당 asset이 import되기 전까지 HTML의 파싱을 중단시키는 것을 말합니다.
브라우저는 HTML파싱과 더불어 DOM을 만들어 완성됐을 때, CSSOM을 만듭니다. DOM과 CSSOM 생성을 마치면 브라우저는 랜더 트리를 생성하고, 눈에 보이는 (visible) 모든 요소들의 스타일을 계산합니다.
랜더트리가 완성되면 레이아웃이 발생합니다. 레이아웃에서는 랜더 트리의 모든 요소의 크기와 위치가 정해집니다.
완성된 페이지는 랜더링을 마치거나 화면에 페인트됩니다.

### DOM

DOM 형성은 점진적으로 증가합니다.
HTML 응답은 토큰이 되며, 이 토큰은 DOM 트리의 노드들이 됩니다.
하나의 DOM 노드는 시작태그 토큰에서부터 끝태그 토큰에서 끝납니다.
노드들은 HTML 엘리먼트와 관련된 모든 정보를 담고 있습니다.
노드들은 토큰의 계층에 따라서 DOM 트리에 연결됩니다.
노드의 게층은 노드 안에 노드가 위치한 구조들로 결정됩니다.
하나의 시작태그와 끝태그 쌍 사이에 다른 쌍의 시작과 끝태그가 들어간다면, 노드 안에 노드가 있는 형태입니다.

노드의 개수가 많을 수록, CRP 내의 과정이 더 오래 걸리고, 이는 성능에 악영향을 미칠 수 있습니다.

### CSSOM

DOM은 페이지의 모든 '내용'에 관한 것들을 담고 있습니다.
반면, CSSOM은 DOM의 모든 것들을 어떻게 스타일링할 것인지에 대한 정보를 담고 있습니다. CSSOM은 DOM과 비슷하지만, 살짝 다릅니다.
DOM 형성은 점진적으로 증가하지만, CSSOM은 랜더링을 중지(render blocking)합니다.
즉, 브라우저는 모든 css를 받아서 처리할 때까지 페이지의 랜더링을 중단합니다. CSS는 스타일링 규칙이 덮어쓰일 수도 있으므로 CSSOM이 완성될 때까지는 내용이 랜더링될 수 없습니다.

CSS는 타당한 토큰들을 정의할 규칙을 따로 갖고 있습니다.
CSS의 C는 cascade(작은 폭포)를 뜻합니다.
즉, css의 규칙들은 위에서 아래로 흘러내리죠.
파서가 토큰들을 노드로 변환하면서, 자손 노드들은 부모 노드들의 스타일을 상속받을 수도 있습니다.
CSS는 스타일 오버라이딩이 있을 수 있어, HTML과 같은 점진적인 프로세싱이 작용하지 않습니다.
CSS이 파싱되면서 CSSOM이 만들어지지만 완전히 파싱이 종료될 때까지 랜더트리를 만들기 위해 쓰일 수는 없습니다. 나중에 파싱된 요소들에 의해 오버라이딩된 스타일들을 스크린에 랜더하면 안되기 때문이죠.

선택자 성능 (selector performance)는 더 상세한 것을 사용할 수록, 더 느려집니다. 예를 들어, `.foo {}`를 사용하는 것이 `.bar.foo{}`를 사용하는 것보다 빠릅니다. 왜냐하면, 브라우저는 `.foo.bar`의 경우 `.foo`를 찾고, `.bar`가 조상 선택자 중에 있는 지 확인을 해야 합니다.
물론 더 자세한 선택자들을 사용하는 것이 브라우저가 할일을 늘리기는 하지만, 굳이 최적화가 필요한 영역은 아닙니다.

CSS를 파싱 시간은 매우 빠릅니다. 더 자세한 선택자들을 사용하는 것이 DOM 노드를 순회하는 시간을 늘리기는 하지만, 유의미할 정도는 아니죠.
먼저 속도를 확인해보고, 필요 시에 최적화를 하세요.
CSS 최적화를 하는 방법은 여러가지입니다. minification, deferred CSS를 미디어 쿼리를 통해 non-blocking으로 분리하는 등이 있습니다.

### 랜더 트리

랜더 트리는 내용과 스타일 모두를 담고 있습니다. 브라우저는 랜더트리를 생성하기 위해 DOM트리의 루트에서 시작해서 모든 노드들을 확인하고, 각 노드에 어떤 CSS 규칙이 적용되는 지 결정합니다. 즉, DOM과 CSSOM 트리가 합쳐져 랜더 트리가 됩니다. 랜더 트리는 오로지 visible 한 것만 고려합니다. `head section`은 주로 눈에 보이는 것들을 담지 않으므로 랜더트리에 포함되지 않습니다.
`display: none;` 또한 엘리먼트에 적용도면 해당 엘리먼트를 포함한 모든 자손들 또한 랜더트리에 있지 않습니다.

### 레이아웃

랜더트리가 생성되었다면, 레이아웃이 시작됩니다.
레이아웃은 스크린의 크기에 따라 달라집니다.
레이아웃은 요소들이 페이지 상 어디에 어떻게 위치되어 있는지와, 각각 요소의 높이와 넓이, 그리고 서로 어떻게 배치되어 있는 지 등이 결정됩니다.

요소의 넓이는 뭔가요? block 레벨 요소들은 디폴트로 부모 넓이의 100%를 지닙니다. 넓이가 50%인 요소는 부모의 넓이의 50%가 됩니다.
따로 지정이 되지 않은 경우, body의 넓이는 100%입니다.
즉, 뷰포트의 100%를 차지합니다. 이 레이아웃의 넓이는 기기에 따라 달라집니다.

뷰포트의 meta 태그는 뷰포트 레이아웃의 넓이를 정하므로 레이아웃에 영향을 줍니다. 이 태그가 없으면 브라우저는 디폴트 뷰포트 넓이인 960px을 사용하게 됩니다. `<meta name="viewport" content="width=device-width">`로 설정을 하게 된다면 디폴트 뷰포트 넓이가 아닌 기기의 넓이를 적용합니다. 기기 넓이는 사용자가 폰을 돌려 가로나 세로로 볼 때 변합니다. 이와 같이 폰은 돌리거나 브라우저 크기를 늘리거나 줄일 경우마다 레이아웃이 발생합니다.

레이아웃 성능은 DOM의 영향을 받습니다.
노드의 개수가 많을수록 더 레이아웃을 하기 위한 시간이 오래 걸립니다.
레이아웃은 병목현상을 일으켜서, 스크롤을 하거나 다른 애니메이션이 필요할 때 화면 버벅거림을 일으킬 수 있습니다.
로드를 하거나 가로/세로 보기 변경이 20ms 딜레이를 일으킨다면 괜찮겠지만, 애니메이션이나 스크롤 시에 버벅거림을 일으킬 수 있습니다. 노드가 추가되거나 내용이 변경되거나, 노드의 box model 스타일이 변경되는 등, 랜더트리가 변경될 때마다, 레이아웃이 발생합니다.

레이아웃 이벤트 발생의 빈도수와 시간을 줄이기 위해서는 일괄 업데이트를 하고, box model 속성을 애니메이션화 하지 말아야 합니다.

### Paint

레이아웃 과정이 완성되면, 마지막 단계는 화면에 픽셀로 그리는 것입니다.
랜더트리가 생성되고 레이아웃이 발생하면, 화면에 픽셀들을 그릴 수 있습니다.
로드가 되면 전체 화면이 paint됩니다. 그 후, 스크린 내에서 영향을 받는 영역들만 repaint 되고, 모든 브라우저들은 이 repaint 영역이 최소화되도록 최적화되어 있습니다.
Paint 시간은 랜더트리에 어떤 업데이트가 적용되는 지에 따라 달라집니다. Paint하는 과정이 매우 빠른 과정이기는 하나, 애니메이션 프레임 소요시간은 레이아웃과 re-paint과정이 모두 영향을 미칠 수 있다는 점에서 둘을 모두 고려해야 합니다. 각 노드에 적용된 스타일은 페인트 시간을 증가시키지만 페인트 시간을 0.001ms 증가시키는 스타일을 제거하는 것이 최적화 비용을 낭비하는 것일 수도 있죠.

## CRP 최적화 방안

1. critical resource의 개수를 최소화하세요. 랜더링에 필수가 아닌 resource를 defer하거나, async 하거나, 불필요한 경우 제거하세요.
2. 각 요청의 파일 크기와 요청의 개수를 최적화하세요.
3. critical resource가 로딩되는 순서를 최적화하세요: critical asset을 우선적으로 load 해서 critical path 길이를 줄여보세요.

## References

- [critical rendering path](https://developer.mozilla.org/en-US/docs/Web/Performance/Critical_rendering_path)
